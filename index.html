<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üé™ Cultural Grammar Synthesis</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
                <button class="intent" data-intent="seduce">
                    üíï<br>SEDUCE
                </button>
                <button class="intent" data-intent="scramble">
                    üß†<br>SCRAMBLE
                </button>
                <button class="intent" data-intent="story">
                    üé≠<br>STORY
                </button>
                <button class="intent" data-intent="hype">
                    üèÉ<br>HYPE
                </button>
                <button class="intent" data-intent="chill">
                    üòå<br>CHILL
                </button>
                <button class="intent" data-intent="cry">
                    üò¢<br>CRY
                </button>
            </div>
            
            <div class="text-center">
                <button class="intent primary" data-intent="surprise" style="width: 100%; padding: 2rem;">
                    üé™ SURPRISE ME
                </button>
            </div>
        </div>
        
        <!-- STATE 3: VIBE INPUT -->
        <div id="vibe-input" class="state">
            <button id="back-to-intents" class="back-btn">‚Üê back</button>
            
            <div class="text-center mb-2">
                <h2 id="intent-title"></h2>
            </div>
            
            <div class="mb-2">
                <label>Optional: Add context to guide it
                    <small>(or leave blank for pure random)</small>
                </label>
                <textarea 
                    id="vibe-textarea" 
                    placeholder="falling in love during a hostage negotiation..."></textarea>
            </div>
            
            <div class="text-center">
                <button id="generate-btn" class="primary">GENERATE</button>
            </div>
        </div>
        
        <!-- STATE 4: GENERATING -->
        <div id="generating" class="state">
            <div class="text-center mb-2">
                <h2>üé≤ Generating...</h2>
                <p id="status-text">Analyzing vibe...</p>
            </div>
            
            <div class="progress-container">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
            
            <div id="pass-display" class="mt-2">
                <!-- Pass details will be inserted here -->
            </div>
        </div>
        
        <!-- STATE 5: RESULT -->
        <div id="result" class="state">
            <button id="back-to-new" class="back-btn">‚Üê new collision</button>
            
            <div class="text-center mb-2">
                <h2 id="result-title">‚ú® YOUR COLLISION ‚ú®</h2>
                <p id="result-subtitle"></p>
            </div>
            
            <div class="text-center mb-2">
                <button id="copy-both" class="primary" style="font-size: 1.2rem; padding: 1.5rem 3rem;">
                    üìã COPY TO SUNO
                </button>
            </div>
            
            <details class="mb-2">
                <summary>üéµ Music Style Prompt</summary>
                <pre id="music-prompt-text"></pre>
            </details>
            
            <details class="mb-2">
                <summary>üìù Lyrics</summary>
                <pre id="lyrics-text"></pre>
            </details>
            
            <div class="text-center mt-2">
                <button id="make-another">üé≤ MAKE ANOTHER</button>
            </div>
        </div>
        
    </div>
    
    <!-- Toast container -->
    <div id="toast-container"></div>
    
    <script>
// ========================================
// DATA: MINI MUSIC GENRES (20 for MVP)
// ========================================

    <script>
// ========================================
// DATA: LOAD FROM JSON LIBRARIES
// ========================================

let MUSIC_GENRES = [];
let LITERARY_STYLES = [];
let LIBRARIES_LOADED = false;

async function loadLibraries() {
    try {
        showToast('üìö Loading genre libraries...');
        
        const [genresData, stylesData] = await Promise.all([
            fetch('libraries/music-genres.json').then(r => r.json()),
            fetch('libraries/literary-styles.json').then(r => r.json())
        ]);
        
        // Flatten categories into single array
        MUSIC_GENRES = Object.values(genresData.categories).flat();
        LITERARY_STYLES = Object.values(stylesData.categories).flat();
        
        console.log(`‚úÖ Loaded ${MUSIC_GENRES.length} music genres`);
        console.log(`‚úÖ Loaded ${LITERARY_STYLES.length} literary styles`);
        
        LIBRARIES_LOADED = true;
        showToast(`‚úÖ Loaded ${MUSIC_GENRES.length} genres!`);
        return true;
    } catch (error) {
        console.error('‚ùå Failed to load libraries:', error);
        showToast('‚ùå Failed to load libraries! Check console.', 'error');
        throw new Error('Failed to load genre libraries');
    }
}

const INTENT_CONFIGS = {
    laugh: {
        name: "Make Me Laugh",
        emoji: "üéâ",
        constraints: {
            temporal_distance: "maximum",
            cultural_distance: "maximum"
        },
        lyrics_default: "sung_words"
    },
    banger: {
        name: "Make A Banger",
        emoji: "üî•",
        constraints: {
            bpm_range: [120, 150],
            arousal_min: 0.8
        },
        lyrics_default: "structure_only"
    },
    seduce: {
        name: "Seduce Someone",
        emoji: "üíï",
        constraints: {
            bpm_range: [60, 100],
            warmth_min: 0.7
        },
        lyrics_default: "sung_words"
    },
    scramble: {
        name: "Scramble My Brain",
        emoji: "üß†",
        constraints: {
            complexity: "maximum"
        },
        lyrics_default: "post_coherent_full"
    },
    story: {
        name: "Tell A Story",
        emoji: "üé≠",
        constraints: {
            emotional_range: "wide"
        },
        lyrics_default: "sung_words_narrative"
    },
    hype: {
        name: "Get Me Hyped",
        emoji: "üèÉ",
        constraints: {
            bpm_range: [140, 180],
            arousal_min: 0.9
        },
        lyrics_default: "structure_only"
    },
    chill: {
        name: "Chill Me Out",
        emoji: "üòå",
        constraints: {
            bpm_max: 80,
            arousal_max: 0.4
        },
        lyrics_default: "instrumental"
    },
    cry: {
        name: "Make Me Cry",
        emoji: "üò¢",
        constraints: {
            valence_max: 0.3
        },
        lyrics_default: "sung_words_emotional"
    },
    surprise: {
        name: "Surprise Me",
        emoji: "üé™",
        constraints: {},
        lyrics_default: "random"
    }
};

// ========================================
// STATE MANAGEMENT
// ========================================

const APP_STATE = {
    current: 'api-gate',
    intent: null,
    vibe: null,
    apiKey: null,
    result: null
};

function setState(newState) {
    document.querySelectorAll('.state').forEach(el => {
        el.classList.remove('active');
    });
    document.getElementById(newState).classList.add('active');
    APP_STATE.current = newState;
}

// ========================================
// API KEY HANDLING
// ========================================

function initApp() {
    const storedKey = localStorage.getItem('claude_api_key');
    if (storedKey) {
        APP_STATE.apiKey = storedKey;
        setState('intent-selection');
        showToast('‚ú® Welcome back!');
    }
}

async function validateKey(key) {
    // Skip API validation - just check format
    // Will validate when actually generating
    return key.length > 50 && key.startsWith('sk-ant-api03-');
}

async function validateAndProceed(key) {
    showToast('Validating API key...');
    const valid = await validateKey(key);
    if (valid) {
        showToast('‚ú® Valid key!');
        setState('intent-selection');
    } else {
        showToast('‚ö†Ô∏è Invalid key', 'error');
        localStorage.removeItem('claude_api_key');
        setState('api-gate');
    }
}

// ========================================
// GENRE SELECTION (CLIENT-SIDE)
// ========================================

function selectGenresForIntent(intent, vibe = null) {
    const config = INTENT_CONFIGS[intent];
    
    let eligible = MUSIC_GENRES.filter(g => {
        if (config.constraints.bpm_range) {
            const [min, max] = config.constraints.bpm_range;
            if (g.bpm[1] < min || g.bpm[0] > max) return false;
        }
        if (config.constraints.bpm_max) {
            if (g.bpm[0] > config.constraints.bpm_max) return false;
        }
        return true;
    });
    
    const selected = [];
    const usedCategories = new Set();
    
    while (selected.length < 3 && eligible.length > 0) {
        const randomIndex = Math.floor(Math.random() * eligible.length);
        const genre = eligible[randomIndex];
        
        if (!usedCategories.has(genre.category)) {
            selected.push(genre);
            usedCategories.add(genre.category);
        }
        
        eligible.splice(randomIndex, 1);
    }
    
    while (selected.length < 3) {
        const randomGenre = MUSIC_GENRES[Math.floor(Math.random() * MUSIC_GENRES.length)];
        if (!selected.includes(randomGenre)) {
            selected.push(randomGenre);
        }
    }
    
    return selected;
}

function selectLiteraryStyles(count = 2) {
    const shuffled = [...LITERARY_STYLES].sort(() => Math.random() - 0.5);
    return shuffled.slice(0, count);
}

// ========================================
// CONTRADICTION ANALYSIS (CLIENT-SIDE)
// ========================================

function analyzeContradictions(genres) {
    const contradictions = [];
    
    const bpms = genres.map(g => g.bpm[0]);
    const bpmRange = Math.max(...bpms) - Math.min(...bpms);
    if (bpmRange > 50) {
        contradictions.push({
            type: 'temporal',
            description: `BPM collision: ${Math.min(...bpms)} to ${Math.max(...bpms)}`
        });
    }
    
    const ceremonials = genres.map(g => g.ceremonial);
    const ceremonialRange = Math.max(...ceremonials) - Math.min(...ceremonials);
    if (ceremonialRange > 0.5) {
        contradictions.push({
            type: 'cultural',
            description: 'Sacred vs. profane collision'
        });
    }
    
    const centers = genres.map(g => g.spectral.center);
    const freqSeparation = Math.max(...centers) - Math.min(...centers);
    if (freqSeparation > 1000) {
        contradictions.push({
            type: 'spectral',
            description: `Frequency separation: ${Math.round(freqSeparation)}Hz`
        });
    }
    
    return contradictions;
}

// ========================================
// CLAUDE API CALLS
// ========================================

async function callClaude(prompt, model = 'claude-3-haiku-20240307') {
    const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
            'x-api-key': APP_STATE.apiKey,
            'anthropic-version': '2023-06-01',
            'content-type': 'application/json'
        },
        body: JSON.stringify({
            model: model,
            max_tokens: 4096,
            messages: [{ role: 'user', content: prompt }]
        })
    });
    
    if (!response.ok) {
        const error = await response.text();
        throw new Error('API call failed: ' + error);
    }
    
    const data = await response.json();
    return data.content[0].text;
}

// ========================================
// SYNTHESIS ENGINE
// ========================================

async function generateCollision(intent, vibe) {
    updateProgress(0, 'Selecting genres...');
    
    const genres = selectGenresForIntent(intent, vibe);
    const styles = selectLiteraryStyles(2);
    
    updateProgress(20, `Found: ${genres.map(g => g.name).join(' + ')}`);
    
    const contradictions = analyzeContradictions(genres);
    
    updateProgress(40, 'Analyzing contradictions...');
    
    const structurePrompt = `You are a music collision synthesizer. Create an IMPOSSIBLE fusion.

GENRES TO COLLIDE:
${genres.map(g => `- ${g.name}: ${g.keywords.join(', ')}, ${g.bpm[0]}-${g.bpm[1]} BPM`).join('\n')}

CONTRADICTIONS DETECTED:
${contradictions.map(c => `- ${c.type}: ${c.description}`).join('\n')}

INTENT: ${INTENT_CONFIGS[intent].name}
${vibe ? `VIBE: ${vibe}` : ''}

Choose ONE impossible structure:
1. ORBITAL - Genres circle without touching, like planets
2. FRACTAL - Nested loops within loops
3. ENTANGLED - Quantum superposition, both at once
4. METABOLIC - Breathing cycles between genres
5. HAUNTOLOGICAL - Past and future collapsed
6. PROCESSIONAL - Ceremonial march through genres
7. INVERTED - Structure turns inside-out

Generate a Suno-ready music style prompt that:
- Uses genre tags creatively
- Specifies BPM if relevant
- Includes production style
- Is max 200 characters

Format:
STRUCTURE: [name]
MUSIC PROMPT:
[your Suno prompt here]`;
    
    updateProgress(60, 'Choosing structure...');
    
    const structureResponse = await callClaude(structurePrompt, 'claude-3-5-sonnet-20241022');
    
    const lyricsPrompt = `Generate lyrics for this musical collision.

GENRES: ${genres.map(g => g.name).join(', ')}
LITERARY STYLES: ${styles.map(s => s.name).join(', ')}
STRUCTURE: ${structureResponse}
INTENT: ${INTENT_CONFIGS[intent].name}
${vibe ? `VIBE: ${vibe}` : ''}

CRITICAL RULES:
1. Only sung/screamed/vocalized content
2. NO production notes like "(tempo increases)" or "(bass drops)"
3. Use [Section Name] for guidance
4. Keep it weird and impossible

Format:
[Verse 1]
[actual words to sing]

[Chorus]
[actual words to sing]`;
    
    updateProgress(80, 'Generating lyrics...');
    
    const lyricsResponse = await callClaude(lyricsPrompt, 'claude-3-5-sonnet-20241022');
    
    updateProgress(100, 'Complete!');
    
    return {
        genres: genres,
        styles: styles,
        contradictions: contradictions,
        musicPrompt: extractMusicPrompt(structureResponse),
        lyrics: lyricsResponse.trim()
    };
}

function extractMusicPrompt(response) {
    const match = response.match(/MUSIC PROMPT:\s*\n(.+?)(?=\n\n|\n\[|$)/s);
    if (match) return match[1].trim();
    
    const lines = response.split('\n');
    for (let i = 0; i < lines.length; i++) {
        if (lines[i].includes('MUSIC PROMPT:')) {
            return lines[i + 1]?.trim() || response;
        }
    }
    
    return response.split('\n').filter(line => 
        !line.includes('STRUCTURE:') && line.trim()
    ).join(' ').slice(0, 200);
}

// ========================================
// UI HELPERS
// ========================================

function updateProgress(percent, text) {
    document.getElementById('progress-bar').style.width = `${percent}%`;
    document.getElementById('status-text').textContent = text;
}

function showToast(message, type = 'success') {
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.textContent = message;
    document.getElementById('toast-container').appendChild(toast);
    
    setTimeout(() => toast.remove(), 3000);
}

function displayResult(result) {
    document.getElementById('result-subtitle').textContent = 
        result.genres.map(g => g.name).join(' √ó ');
    
    document.getElementById('music-prompt-text').textContent = result.musicPrompt;
    document.getElementById('lyrics-text').textContent = result.lyrics;
}

function copyToClipboard() {
    const musicPrompt = document.getElementById('music-prompt-text').textContent;
    const lyrics = document.getElementById('lyrics-text').textContent;
    
    const formatted = `=== MUSIC STYLE ===
Paste into Suno's "Style of Music" field:

${musicPrompt}

=== LYRICS ===
Paste into Suno's "Lyrics" field:

${lyrics}`;
    
    navigator.clipboard.writeText(formatted);
    
    // Trigger success animation
    const btn = document.getElementById('copy-both');
    btn.classList.add('copied');
    setTimeout(() => btn.classList.remove('copied'), 500);
    
    showToast('‚úì Copied! Paste into Suno');
}

// ========================================
// EVENT LISTENERS
// ========================================

document.addEventListener('DOMContentLoaded', async () => {
    // Load libraries first
    try {
        await loadLibraries();
    } catch (err) {
        showToast('Failed to load libraries: ' + err.message, 'error');
        return;
    }
    
    initApp();
    
    document.getElementById('submit-api-key').addEventListener('click', async () => {
        const key = document.getElementById('api-key-input').value.trim();
        
        if (!key.startsWith('sk-ant-api03-')) {
            showToast('Key should start with sk-ant-api03-', 'error');
            return;
        }
        
        if (document.getElementById('remember-key').checked) {
            localStorage.setItem('claude_api_key', key);
        }
        
        APP_STATE.apiKey = key;
        await validateAndProceed(key);
    });
    
    document.querySelectorAll('.intent').forEach(btn => {
        btn.addEventListener('click', (e) => {
            APP_STATE.intent = e.currentTarget.dataset.intent;
            document.getElementById('intent-title').textContent = 
                INTENT_CONFIGS[APP_STATE.intent].emoji + ' ' + 
                INTENT_CONFIGS[APP_STATE.intent].name;
            setState('vibe-input');
        });
    });
    
    document.getElementById('back-to-intents').addEventListener('click', () => {
        setState('intent-selection');
    });
    
    document.getElementById('back-to-new').addEventListener('click', () => {
        setState('intent-selection');
    });
    
    document.getElementById('generate-btn').addEventListener('click', async () => {
        // Check libraries loaded
        if (!LIBRARIES_LOADED || MUSIC_GENRES.length === 0 || LITERARY_STYLES.length === 0) {
            showToast('‚ùå Libraries not loaded! Refresh the page.', 'error');
            return;
        }
        
        APP_STATE.vibe = document.getElementById('vibe-textarea').value;
        setState('generating');
        
        try {
            const result = await generateCollision(APP_STATE.intent, APP_STATE.vibe);
            APP_STATE.result = result;
            displayResult(result);
            setState('result');
        } catch (err) {
            showToast('Generation failed: ' + err.message, 'error');
            setState('vibe-input');
        }
    });
    
    document.getElementById('copy-both').addEventListener('click', copyToClipboard);
    
    document.getElementById('make-another').addEventListener('click', () => {
        document.getElementById('vibe-textarea').value = '';
        setState('vibe-input');
    });
});
    </script>
</body>
</html>
